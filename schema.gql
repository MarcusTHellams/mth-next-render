# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateComment {
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
}

type AggregateProject {
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
}

type AggregateProjectsOnUser {
  _count: ProjectsOnUserCountAggregate
  _max: ProjectsOnUserMaxAggregate
  _min: ProjectsOnUserMinAggregate
}

type AggregateRole {
  _avg: RoleAvgAggregate
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
  _sum: RoleSumAggregate
}

type AggregateRolesOnUsers {
  _avg: RolesOnUsersAvgAggregate
  _count: RolesOnUsersCountAggregate
  _max: RolesOnUsersMaxAggregate
  _min: RolesOnUsersMinAggregate
  _sum: RolesOnUsersSumAggregate
}

type AggregateTicket {
  _count: TicketCountAggregate
  _max: TicketMaxAggregate
  _min: TicketMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Comment {
  commenter: User!
  commenterId: String!
  id: String!
  message: String!
  ticket: Ticket!
  ticketId: String!
}

type CommentCountAggregate {
  _all: Int!
  commenterId: Int!
  id: Int!
  message: Int!
  ticketId: Int!
}

input CommentCountOrderByAggregateInput {
  commenterId: SortOrder
  id: SortOrder
  message: SortOrder
  ticketId: SortOrder
}

input CommentCreateInput {
  commenter: UserCreateNestedOneWithoutCommentsInput!
  id: String
  message: String!
  ticket: TicketCreateNestedOneWithoutCommentsInput!
}

input CommentCreateNestedManyWithoutCommenterInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutCommenterInput!]
  create: [CommentCreateWithoutCommenterInput!]
}

input CommentCreateNestedManyWithoutTicketInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutTicketInput!]
  create: [CommentCreateWithoutTicketInput!]
}

input CommentCreateOrConnectWithoutCommenterInput {
  create: CommentCreateWithoutCommenterInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutTicketInput {
  create: CommentCreateWithoutTicketInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutCommenterInput {
  id: String
  message: String!
  ticket: TicketCreateNestedOneWithoutCommentsInput!
}

input CommentCreateWithoutTicketInput {
  commenter: UserCreateNestedOneWithoutCommentsInput!
  id: String
  message: String!
}

type CommentGroupBy {
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
  commenterId: String!
  id: String!
  message: String!
  ticketId: String!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregate {
  commenterId: String
  id: String
  message: String
  ticketId: String
}

input CommentMaxOrderByAggregateInput {
  commenterId: SortOrder
  id: SortOrder
  message: SortOrder
  ticketId: SortOrder
}

type CommentMinAggregate {
  commenterId: String
  id: String
  message: String
  ticketId: String
}

input CommentMinOrderByAggregateInput {
  commenterId: SortOrder
  id: SortOrder
  message: SortOrder
  ticketId: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByWithAggregationInput {
  _count: CommentCountOrderByAggregateInput
  _max: CommentMaxOrderByAggregateInput
  _min: CommentMinOrderByAggregateInput
  commenterId: SortOrder
  id: SortOrder
  message: SortOrder
  ticketId: SortOrder
}

input CommentOrderByWithRelationInput {
  commenter: UserOrderByWithRelationInput
  commenterId: SortOrder
  id: SortOrder
  message: SortOrder
  ticket: TicketOrderByWithRelationInput
  ticketId: SortOrder
}

enum CommentScalarFieldEnum {
  commenterId
  id
  message
  ticketId
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  commenterId: StringFilter
  id: StringFilter
  message: StringFilter
  ticketId: StringFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput!]
  NOT: [CommentScalarWhereWithAggregatesInput!]
  OR: [CommentScalarWhereWithAggregatesInput!]
  commenterId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  message: StringWithAggregatesFilter
  ticketId: StringWithAggregatesFilter
}

input CommentUpdateInput {
  commenter: UserUpdateOneRequiredWithoutCommentsNestedInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  ticket: TicketUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutCommenterInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutTicketInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutCommenterNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutCommenterInput!]
  create: [CommentCreateWithoutCommenterInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutCommenterInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutCommenterInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutCommenterInput!]
}

input CommentUpdateManyWithoutTicketNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutTicketInput!]
  create: [CommentCreateWithoutTicketInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutTicketInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutTicketInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutTicketInput!]
}

input CommentUpdateWithWhereUniqueWithoutCommenterInput {
  data: CommentUpdateWithoutCommenterInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutTicketInput {
  data: CommentUpdateWithoutTicketInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutCommenterInput {
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  ticket: TicketUpdateOneRequiredWithoutCommentsNestedInput
}

input CommentUpdateWithoutTicketInput {
  commenter: UserUpdateOneRequiredWithoutCommentsNestedInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
}

input CommentUpsertWithWhereUniqueWithoutCommenterInput {
  create: CommentCreateWithoutCommenterInput!
  update: CommentUpdateWithoutCommenterInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutTicketInput {
  create: CommentCreateWithoutTicketInput!
  update: CommentUpdateWithoutTicketInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  commenter: UserRelationFilter
  commenterId: StringFilter
  id: StringFilter
  message: StringFilter
  ticket: TicketRelationFilter
  ticketId: StringFilter
}

input CommentWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input ManageUserRolesInput {
  role: Int!
  users: [String!]!
}

type Mutation {
  addMine(input: MyInput!): String!
  createOneComment(data: CommentCreateInput!): Comment!
  createOneProject(data: ProjectCreateInput!): Project!
  createOneProjectsOnUser(data: ProjectsOnUserCreateInput!): ProjectsOnUser!
  createOneRole(data: RoleCreateInput!): Role!
  createOneRolesOnUsers(data: RolesOnUsersCreateInput!): RolesOnUsers!
  createOneTicket(data: TicketCreateInput!): Ticket!
  createOneUser(data: UserCreateInput!): User!
  deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
  deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
  deleteManyProjectsOnUser(where: ProjectsOnUserWhereInput): AffectedRowsOutput!
  deleteManyRole(where: RoleWhereInput): AffectedRowsOutput!
  deleteManyRolesOnUsers(where: RolesOnUsersWhereInput): AffectedRowsOutput!
  deleteManyTicket(where: TicketWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneComment(where: CommentWhereUniqueInput!): Comment
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOneProjectsOnUser(where: ProjectsOnUserWhereUniqueInput!): ProjectsOnUser
  deleteOneRole(where: RoleWhereUniqueInput!): Role
  deleteOneRolesOnUsers(where: RolesOnUsersWhereUniqueInput!): RolesOnUsers
  deleteOneTicket(where: TicketWhereUniqueInput!): Ticket
  deleteOneUser(where: UserWhereUniqueInput!): User
  manageUserRoles(input: ManageUserRolesInput!): String!
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): AffectedRowsOutput!
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): AffectedRowsOutput!
  updateManyProjectsOnUser(data: ProjectsOnUserUpdateManyMutationInput!, where: ProjectsOnUserWhereInput): AffectedRowsOutput!
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): AffectedRowsOutput!
  updateManyRolesOnUsers(data: RolesOnUsersUpdateManyMutationInput!, where: RolesOnUsersWhereInput): AffectedRowsOutput!
  updateManyTicket(data: TicketUpdateManyMutationInput!, where: TicketWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOneProjectsOnUser(data: ProjectsOnUserUpdateInput!, where: ProjectsOnUserWhereUniqueInput!): ProjectsOnUser
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateOneRolesOnUsers(data: RolesOnUsersUpdateInput!, where: RolesOnUsersWhereUniqueInput!): RolesOnUsers
  updateOneTicket(data: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertOneProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertOneProjectsOnUser(create: ProjectsOnUserCreateInput!, update: ProjectsOnUserUpdateInput!, where: ProjectsOnUserWhereUniqueInput!): ProjectsOnUser!
  upsertOneRole(create: RoleCreateInput!, update: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  upsertOneRolesOnUsers(create: RolesOnUsersCreateInput!, update: RolesOnUsersUpdateInput!, where: RolesOnUsersWhereUniqueInput!): RolesOnUsers!
  upsertOneTicket(create: TicketCreateInput!, update: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input MyInput {
  age: Int!
  title: String!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Project {
  _count: ProjectCount
  assignedPersonnel(cursor: ProjectsOnUserWhereUniqueInput, distinct: [ProjectsOnUserScalarFieldEnum!], orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): [ProjectsOnUser!]!
  createdAt: DateTime!
  description: String!
  id: String!
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
  title: String!
  updatedAt: DateTime!
}

type ProjectCount {
  assignedPersonnel: Int!
  roles: Int!
  tickets: Int!
}

type ProjectCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
}

input ProjectCountOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input ProjectCreateInput {
  assignedPersonnel: ProjectsOnUserCreateNestedManyWithoutProjectInput
  createdAt: DateTime
  description: String!
  id: String
  roles: RoleCreateNestedManyWithoutProjectInput
  tickets: TicketCreateNestedManyWithoutProjectInput
  title: String!
  updatedAt: DateTime
}

input ProjectCreateNestedOneWithoutAssignedPersonnelInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutAssignedPersonnelInput
  create: ProjectCreateWithoutAssignedPersonnelInput
}

input ProjectCreateNestedOneWithoutRolesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutRolesInput
  create: ProjectCreateWithoutRolesInput
}

input ProjectCreateNestedOneWithoutTicketsInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTicketsInput
  create: ProjectCreateWithoutTicketsInput
}

input ProjectCreateOrConnectWithoutAssignedPersonnelInput {
  create: ProjectCreateWithoutAssignedPersonnelInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutRolesInput {
  create: ProjectCreateWithoutRolesInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutTicketsInput {
  create: ProjectCreateWithoutTicketsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutAssignedPersonnelInput {
  createdAt: DateTime
  description: String!
  id: String
  roles: RoleCreateNestedManyWithoutProjectInput
  tickets: TicketCreateNestedManyWithoutProjectInput
  title: String!
  updatedAt: DateTime
}

input ProjectCreateWithoutRolesInput {
  assignedPersonnel: ProjectsOnUserCreateNestedManyWithoutProjectInput
  createdAt: DateTime
  description: String!
  id: String
  tickets: TicketCreateNestedManyWithoutProjectInput
  title: String!
  updatedAt: DateTime
}

input ProjectCreateWithoutTicketsInput {
  assignedPersonnel: ProjectsOnUserCreateNestedManyWithoutProjectInput
  createdAt: DateTime
  description: String!
  id: String
  roles: RoleCreateNestedManyWithoutProjectInput
  title: String!
  updatedAt: DateTime
}

type ProjectGroupBy {
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  createdAt: DateTime!
  description: String!
  id: String!
  title: String!
  updatedAt: DateTime!
}

type ProjectMaxAggregate {
  createdAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
}

input ProjectMaxOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type ProjectMinAggregate {
  createdAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
}

input ProjectMinOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input ProjectOrderByWithAggregationInput {
  _count: ProjectCountOrderByAggregateInput
  _max: ProjectMaxOrderByAggregateInput
  _min: ProjectMinOrderByAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
  assignedPersonnel: ProjectsOnUserOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  roles: RoleOrderByRelationAggregateInput
  tickets: TicketOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
}

input ProjectRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

enum ProjectScalarFieldEnum {
  createdAt
  description
  id
  title
  updatedAt
}

input ProjectScalarWhereWithAggregatesInput {
  AND: [ProjectScalarWhereWithAggregatesInput!]
  NOT: [ProjectScalarWhereWithAggregatesInput!]
  OR: [ProjectScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input ProjectUpdateInput {
  assignedPersonnel: ProjectsOnUserUpdateManyWithoutProjectNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  roles: RoleUpdateManyWithoutProjectNestedInput
  tickets: TicketUpdateManyWithoutProjectNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateOneRequiredWithoutAssignedPersonnelNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutAssignedPersonnelInput
  create: ProjectCreateWithoutAssignedPersonnelInput
  update: ProjectUpdateWithoutAssignedPersonnelInput
  upsert: ProjectUpsertWithoutAssignedPersonnelInput
}

input ProjectUpdateOneRequiredWithoutTicketsNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTicketsInput
  create: ProjectCreateWithoutTicketsInput
  update: ProjectUpdateWithoutTicketsInput
  upsert: ProjectUpsertWithoutTicketsInput
}

input ProjectUpdateOneWithoutRolesNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutRolesInput
  create: ProjectCreateWithoutRolesInput
  delete: Boolean
  disconnect: Boolean
  update: ProjectUpdateWithoutRolesInput
  upsert: ProjectUpsertWithoutRolesInput
}

input ProjectUpdateWithoutAssignedPersonnelInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  roles: RoleUpdateManyWithoutProjectNestedInput
  tickets: TicketUpdateManyWithoutProjectNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutRolesInput {
  assignedPersonnel: ProjectsOnUserUpdateManyWithoutProjectNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  tickets: TicketUpdateManyWithoutProjectNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutTicketsInput {
  assignedPersonnel: ProjectsOnUserUpdateManyWithoutProjectNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  roles: RoleUpdateManyWithoutProjectNestedInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpsertWithoutAssignedPersonnelInput {
  create: ProjectCreateWithoutAssignedPersonnelInput!
  update: ProjectUpdateWithoutAssignedPersonnelInput!
}

input ProjectUpsertWithoutRolesInput {
  create: ProjectCreateWithoutRolesInput!
  update: ProjectUpdateWithoutRolesInput!
}

input ProjectUpsertWithoutTicketsInput {
  create: ProjectCreateWithoutTicketsInput!
  update: ProjectUpdateWithoutTicketsInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  assignedPersonnel: ProjectsOnUserListRelationFilter
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  roles: RoleListRelationFilter
  tickets: TicketListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
  id: String
}

type ProjectsOnUser {
  createdAt: DateTime!
  project: Project!
  projectId: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type ProjectsOnUserCountAggregate {
  _all: Int!
  createdAt: Int!
  projectId: Int!
  updatedAt: Int!
  userId: Int!
}

input ProjectsOnUserCountOrderByAggregateInput {
  createdAt: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ProjectsOnUserCreateInput {
  createdAt: DateTime
  project: ProjectCreateNestedOneWithoutAssignedPersonnelInput!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutProjectsInput!
}

input ProjectsOnUserCreateNestedManyWithoutProjectInput {
  connect: [ProjectsOnUserWhereUniqueInput!]
  connectOrCreate: [ProjectsOnUserCreateOrConnectWithoutProjectInput!]
  create: [ProjectsOnUserCreateWithoutProjectInput!]
}

input ProjectsOnUserCreateNestedManyWithoutUserInput {
  connect: [ProjectsOnUserWhereUniqueInput!]
  connectOrCreate: [ProjectsOnUserCreateOrConnectWithoutUserInput!]
  create: [ProjectsOnUserCreateWithoutUserInput!]
}

input ProjectsOnUserCreateOrConnectWithoutProjectInput {
  create: ProjectsOnUserCreateWithoutProjectInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserCreateOrConnectWithoutUserInput {
  create: ProjectsOnUserCreateWithoutUserInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserCreateWithoutProjectInput {
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutProjectsInput!
}

input ProjectsOnUserCreateWithoutUserInput {
  createdAt: DateTime
  project: ProjectCreateNestedOneWithoutAssignedPersonnelInput!
  updatedAt: DateTime
}

type ProjectsOnUserGroupBy {
  _count: ProjectsOnUserCountAggregate
  _max: ProjectsOnUserMaxAggregate
  _min: ProjectsOnUserMinAggregate
  createdAt: DateTime!
  projectId: String!
  updatedAt: DateTime!
  userId: String!
}

input ProjectsOnUserListRelationFilter {
  every: ProjectsOnUserWhereInput
  none: ProjectsOnUserWhereInput
  some: ProjectsOnUserWhereInput
}

type ProjectsOnUserMaxAggregate {
  createdAt: DateTime
  projectId: String
  updatedAt: DateTime
  userId: String
}

input ProjectsOnUserMaxOrderByAggregateInput {
  createdAt: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type ProjectsOnUserMinAggregate {
  createdAt: DateTime
  projectId: String
  updatedAt: DateTime
  userId: String
}

input ProjectsOnUserMinOrderByAggregateInput {
  createdAt: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ProjectsOnUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProjectsOnUserOrderByWithAggregationInput {
  _count: ProjectsOnUserCountOrderByAggregateInput
  _max: ProjectsOnUserMaxOrderByAggregateInput
  _min: ProjectsOnUserMinOrderByAggregateInput
  createdAt: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ProjectsOnUserOrderByWithRelationInput {
  createdAt: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ProjectsOnUserScalarFieldEnum {
  createdAt
  projectId
  updatedAt
  userId
}

input ProjectsOnUserScalarWhereInput {
  AND: [ProjectsOnUserScalarWhereInput!]
  NOT: [ProjectsOnUserScalarWhereInput!]
  OR: [ProjectsOnUserScalarWhereInput!]
  createdAt: DateTimeFilter
  projectId: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input ProjectsOnUserScalarWhereWithAggregatesInput {
  AND: [ProjectsOnUserScalarWhereWithAggregatesInput!]
  NOT: [ProjectsOnUserScalarWhereWithAggregatesInput!]
  OR: [ProjectsOnUserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  projectId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input ProjectsOnUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutAssignedPersonnelNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutProjectsNestedInput
}

input ProjectsOnUserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectsOnUserUpdateManyWithWhereWithoutProjectInput {
  data: ProjectsOnUserUpdateManyMutationInput!
  where: ProjectsOnUserScalarWhereInput!
}

input ProjectsOnUserUpdateManyWithWhereWithoutUserInput {
  data: ProjectsOnUserUpdateManyMutationInput!
  where: ProjectsOnUserScalarWhereInput!
}

input ProjectsOnUserUpdateManyWithoutProjectNestedInput {
  connect: [ProjectsOnUserWhereUniqueInput!]
  connectOrCreate: [ProjectsOnUserCreateOrConnectWithoutProjectInput!]
  create: [ProjectsOnUserCreateWithoutProjectInput!]
  delete: [ProjectsOnUserWhereUniqueInput!]
  deleteMany: [ProjectsOnUserScalarWhereInput!]
  disconnect: [ProjectsOnUserWhereUniqueInput!]
  set: [ProjectsOnUserWhereUniqueInput!]
  update: [ProjectsOnUserUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [ProjectsOnUserUpdateManyWithWhereWithoutProjectInput!]
  upsert: [ProjectsOnUserUpsertWithWhereUniqueWithoutProjectInput!]
}

input ProjectsOnUserUpdateManyWithoutUserNestedInput {
  connect: [ProjectsOnUserWhereUniqueInput!]
  connectOrCreate: [ProjectsOnUserCreateOrConnectWithoutUserInput!]
  create: [ProjectsOnUserCreateWithoutUserInput!]
  delete: [ProjectsOnUserWhereUniqueInput!]
  deleteMany: [ProjectsOnUserScalarWhereInput!]
  disconnect: [ProjectsOnUserWhereUniqueInput!]
  set: [ProjectsOnUserWhereUniqueInput!]
  update: [ProjectsOnUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProjectsOnUserUpdateManyWithWhereWithoutUserInput!]
  upsert: [ProjectsOnUserUpsertWithWhereUniqueWithoutUserInput!]
}

input ProjectsOnUserUpdateWithWhereUniqueWithoutProjectInput {
  data: ProjectsOnUserUpdateWithoutProjectInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserUpdateWithWhereUniqueWithoutUserInput {
  data: ProjectsOnUserUpdateWithoutUserInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserUpdateWithoutProjectInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutProjectsNestedInput
}

input ProjectsOnUserUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutAssignedPersonnelNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectsOnUserUpsertWithWhereUniqueWithoutProjectInput {
  create: ProjectsOnUserCreateWithoutProjectInput!
  update: ProjectsOnUserUpdateWithoutProjectInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserUpsertWithWhereUniqueWithoutUserInput {
  create: ProjectsOnUserCreateWithoutUserInput!
  update: ProjectsOnUserUpdateWithoutUserInput!
  where: ProjectsOnUserWhereUniqueInput!
}

input ProjectsOnUserUserIdProjectIdCompoundUniqueInput {
  projectId: String!
  userId: String!
}

input ProjectsOnUserWhereInput {
  AND: [ProjectsOnUserWhereInput!]
  NOT: [ProjectsOnUserWhereInput!]
  OR: [ProjectsOnUserWhereInput!]
  createdAt: DateTimeFilter
  project: ProjectRelationFilter
  projectId: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input ProjectsOnUserWhereUniqueInput {
  userId_projectId: ProjectsOnUserUserIdProjectIdCompoundUniqueInput
}

type Query {
  aggregateComment(cursor: CommentWhereUniqueInput, orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): AggregateComment!
  aggregateProject(cursor: ProjectWhereUniqueInput, orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
  aggregateProjectsOnUser(cursor: ProjectsOnUserWhereUniqueInput, orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): AggregateProjectsOnUser!
  aggregateRole(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): AggregateRole!
  aggregateRolesOnUsers(cursor: RolesOnUsersWhereUniqueInput, orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): AggregateRolesOnUsers!
  aggregateTicket(cursor: TicketWhereUniqueInput, orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): AggregateTicket!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  findFirstComment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstCommentOrThrow(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstProjectOrThrow(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstProjectsOnUser(cursor: ProjectsOnUserWhereUniqueInput, distinct: [ProjectsOnUserScalarFieldEnum!], orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): ProjectsOnUser
  findFirstProjectsOnUserOrThrow(cursor: ProjectsOnUserWhereUniqueInput, distinct: [ProjectsOnUserScalarFieldEnum!], orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): ProjectsOnUser
  findFirstRole(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstRoleOrThrow(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstRolesOnUsers(cursor: RolesOnUsersWhereUniqueInput, distinct: [RolesOnUsersScalarFieldEnum!], orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): RolesOnUsers
  findFirstRolesOnUsersOrThrow(cursor: RolesOnUsersWhereUniqueInput, distinct: [RolesOnUsersScalarFieldEnum!], orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): RolesOnUsers
  findFirstTicket(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): Ticket
  findFirstTicketOrThrow(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): Ticket
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyRolesOnUsers(cursor: RolesOnUsersWhereUniqueInput, distinct: [RolesOnUsersScalarFieldEnum!], orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): [RolesOnUsers!]!
  findUniqueRolesOnUsers(where: RolesOnUsersWhereUniqueInput!): RolesOnUsers
  findUniqueRolesOnUsersOrThrow(where: RolesOnUsersWhereUniqueInput!): RolesOnUsers
  getComment(where: CommentWhereUniqueInput!): Comment
  getProject(where: ProjectWhereUniqueInput!): Project
  getProjectsOnUser(where: ProjectsOnUserWhereUniqueInput!): ProjectsOnUser
  getRole(where: RoleWhereUniqueInput!): Role
  getTicket(where: TicketWhereUniqueInput!): Ticket
  getUser(where: UserWhereUniqueInput!): User
  groupByComment(by: [CommentScalarFieldEnum!]!, having: CommentScalarWhereWithAggregatesInput, orderBy: [CommentOrderByWithAggregationInput!], skip: Int, take: Int, where: CommentWhereInput): [CommentGroupBy!]!
  groupByProject(by: [ProjectScalarFieldEnum!]!, having: ProjectScalarWhereWithAggregatesInput, orderBy: [ProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectWhereInput): [ProjectGroupBy!]!
  groupByProjectsOnUser(by: [ProjectsOnUserScalarFieldEnum!]!, having: ProjectsOnUserScalarWhereWithAggregatesInput, orderBy: [ProjectsOnUserOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): [ProjectsOnUserGroupBy!]!
  groupByRole(by: [RoleScalarFieldEnum!]!, having: RoleScalarWhereWithAggregatesInput, orderBy: [RoleOrderByWithAggregationInput!], skip: Int, take: Int, where: RoleWhereInput): [RoleGroupBy!]!
  groupByRolesOnUsers(by: [RolesOnUsersScalarFieldEnum!]!, having: RolesOnUsersScalarWhereWithAggregatesInput, orderBy: [RolesOnUsersOrderByWithAggregationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): [RolesOnUsersGroupBy!]!
  groupByTicket(by: [TicketScalarFieldEnum!]!, having: TicketScalarWhereWithAggregatesInput, orderBy: [TicketOrderByWithAggregationInput!], skip: Int, take: Int, where: TicketWhereInput): [TicketGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  projectsOnUser(where: ProjectsOnUserWhereUniqueInput!): ProjectsOnUser
  projectsOnUsers(cursor: ProjectsOnUserWhereUniqueInput, distinct: [ProjectsOnUserScalarFieldEnum!], orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): [ProjectsOnUser!]!
  role(where: RoleWhereUniqueInput!): Role
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  ticket(where: TicketWhereUniqueInput!): Ticket
  tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!

  """Get Paginated Users"""
  usersPaginated(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): UserPaginatedResponse!
}

type Role {
  _count: RoleCount
  id: Int!
  name: String!
  project: Project
  projectId: String
  user(cursor: RolesOnUsersWhereUniqueInput, distinct: [RolesOnUsersScalarFieldEnum!], orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): [RolesOnUsers!]!
}

type RoleAvgAggregate {
  id: Float
}

input RoleAvgOrderByAggregateInput {
  id: SortOrder
}

type RoleCount {
  user: Int!
}

type RoleCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  projectId: Int!
}

input RoleCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input RoleCreateInput {
  name: String!
  project: ProjectCreateNestedOneWithoutRolesInput
  user: RolesOnUsersCreateNestedManyWithoutRoleInput
}

input RoleCreateNestedManyWithoutProjectInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutProjectInput!]
  create: [RoleCreateWithoutProjectInput!]
}

input RoleCreateNestedOneWithoutUserInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUserInput
  create: RoleCreateWithoutUserInput
}

input RoleCreateOrConnectWithoutProjectInput {
  create: RoleCreateWithoutProjectInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateOrConnectWithoutUserInput {
  create: RoleCreateWithoutUserInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutProjectInput {
  name: String!
  user: RolesOnUsersCreateNestedManyWithoutRoleInput
}

input RoleCreateWithoutUserInput {
  name: String!
  project: ProjectCreateNestedOneWithoutRolesInput
}

type RoleGroupBy {
  _avg: RoleAvgAggregate
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
  _sum: RoleSumAggregate
  id: Int!
  name: String!
  projectId: String
}

input RoleListRelationFilter {
  every: RoleWhereInput
  none: RoleWhereInput
  some: RoleWhereInput
}

type RoleMaxAggregate {
  id: Int
  name: String
  projectId: String
}

input RoleMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

type RoleMinAggregate {
  id: Int
  name: String
  projectId: String
}

input RoleMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input RoleOrderByRelationAggregateInput {
  _count: SortOrder
}

input RoleOrderByWithAggregationInput {
  _avg: RoleAvgOrderByAggregateInput
  _count: RoleCountOrderByAggregateInput
  _max: RoleMaxOrderByAggregateInput
  _min: RoleMinOrderByAggregateInput
  _sum: RoleSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  projectId: SortOrder
}

input RoleOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
  user: RolesOnUsersOrderByRelationAggregateInput
}

input RoleRelationFilter {
  is: RoleWhereInput
  isNot: RoleWhereInput
}

enum RoleScalarFieldEnum {
  id
  name
  projectId
}

input RoleScalarWhereInput {
  AND: [RoleScalarWhereInput!]
  NOT: [RoleScalarWhereInput!]
  OR: [RoleScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  projectId: StringNullableFilter
}

input RoleScalarWhereWithAggregatesInput {
  AND: [RoleScalarWhereWithAggregatesInput!]
  NOT: [RoleScalarWhereWithAggregatesInput!]
  OR: [RoleScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  projectId: StringNullableWithAggregatesFilter
}

type RoleSumAggregate {
  id: Int
}

input RoleSumOrderByAggregateInput {
  id: SortOrder
}

input RoleUpdateInput {
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutRolesNestedInput
  user: RolesOnUsersUpdateManyWithoutRoleNestedInput
}

input RoleUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input RoleUpdateManyWithWhereWithoutProjectInput {
  data: RoleUpdateManyMutationInput!
  where: RoleScalarWhereInput!
}

input RoleUpdateManyWithoutProjectNestedInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutProjectInput!]
  create: [RoleCreateWithoutProjectInput!]
  delete: [RoleWhereUniqueInput!]
  deleteMany: [RoleScalarWhereInput!]
  disconnect: [RoleWhereUniqueInput!]
  set: [RoleWhereUniqueInput!]
  update: [RoleUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [RoleUpdateManyWithWhereWithoutProjectInput!]
  upsert: [RoleUpsertWithWhereUniqueWithoutProjectInput!]
}

input RoleUpdateOneRequiredWithoutUserNestedInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUserInput
  create: RoleCreateWithoutUserInput
  update: RoleUpdateWithoutUserInput
  upsert: RoleUpsertWithoutUserInput
}

input RoleUpdateWithWhereUniqueWithoutProjectInput {
  data: RoleUpdateWithoutProjectInput!
  where: RoleWhereUniqueInput!
}

input RoleUpdateWithoutProjectInput {
  name: StringFieldUpdateOperationsInput
  user: RolesOnUsersUpdateManyWithoutRoleNestedInput
}

input RoleUpdateWithoutUserInput {
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneWithoutRolesNestedInput
}

input RoleUpsertWithWhereUniqueWithoutProjectInput {
  create: RoleCreateWithoutProjectInput!
  update: RoleUpdateWithoutProjectInput!
  where: RoleWhereUniqueInput!
}

input RoleUpsertWithoutUserInput {
  create: RoleCreateWithoutUserInput!
  update: RoleUpdateWithoutUserInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: IntFilter
  name: StringFilter
  project: ProjectRelationFilter
  projectId: StringNullableFilter
  user: RolesOnUsersListRelationFilter
}

input RoleWhereUniqueInput {
  id: Int
  name: String
}

type RolesOnUsers {
  createdAt: DateTime!
  role: Role!
  roleId: Int!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type RolesOnUsersAvgAggregate {
  roleId: Float
}

input RolesOnUsersAvgOrderByAggregateInput {
  roleId: SortOrder
}

type RolesOnUsersCountAggregate {
  _all: Int!
  createdAt: Int!
  roleId: Int!
  updatedAt: Int!
  userId: Int!
}

input RolesOnUsersCountOrderByAggregateInput {
  createdAt: SortOrder
  roleId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RolesOnUsersCreateInput {
  createdAt: DateTime
  role: RoleCreateNestedOneWithoutUserInput!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutRolesInput!
}

input RolesOnUsersCreateNestedManyWithoutRoleInput {
  connect: [RolesOnUsersWhereUniqueInput!]
  connectOrCreate: [RolesOnUsersCreateOrConnectWithoutRoleInput!]
  create: [RolesOnUsersCreateWithoutRoleInput!]
}

input RolesOnUsersCreateNestedManyWithoutUserInput {
  connect: [RolesOnUsersWhereUniqueInput!]
  connectOrCreate: [RolesOnUsersCreateOrConnectWithoutUserInput!]
  create: [RolesOnUsersCreateWithoutUserInput!]
}

input RolesOnUsersCreateOrConnectWithoutRoleInput {
  create: RolesOnUsersCreateWithoutRoleInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersCreateOrConnectWithoutUserInput {
  create: RolesOnUsersCreateWithoutUserInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersCreateWithoutRoleInput {
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutRolesInput!
}

input RolesOnUsersCreateWithoutUserInput {
  createdAt: DateTime
  role: RoleCreateNestedOneWithoutUserInput!
  updatedAt: DateTime
}

type RolesOnUsersGroupBy {
  _avg: RolesOnUsersAvgAggregate
  _count: RolesOnUsersCountAggregate
  _max: RolesOnUsersMaxAggregate
  _min: RolesOnUsersMinAggregate
  _sum: RolesOnUsersSumAggregate
  createdAt: DateTime!
  roleId: Int!
  updatedAt: DateTime!
  userId: String!
}

input RolesOnUsersListRelationFilter {
  every: RolesOnUsersWhereInput
  none: RolesOnUsersWhereInput
  some: RolesOnUsersWhereInput
}

type RolesOnUsersMaxAggregate {
  createdAt: DateTime
  roleId: Int
  updatedAt: DateTime
  userId: String
}

input RolesOnUsersMaxOrderByAggregateInput {
  createdAt: SortOrder
  roleId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type RolesOnUsersMinAggregate {
  createdAt: DateTime
  roleId: Int
  updatedAt: DateTime
  userId: String
}

input RolesOnUsersMinOrderByAggregateInput {
  createdAt: SortOrder
  roleId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RolesOnUsersOrderByRelationAggregateInput {
  _count: SortOrder
}

input RolesOnUsersOrderByWithAggregationInput {
  _avg: RolesOnUsersAvgOrderByAggregateInput
  _count: RolesOnUsersCountOrderByAggregateInput
  _max: RolesOnUsersMaxOrderByAggregateInput
  _min: RolesOnUsersMinOrderByAggregateInput
  _sum: RolesOnUsersSumOrderByAggregateInput
  createdAt: SortOrder
  roleId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input RolesOnUsersOrderByWithRelationInput {
  createdAt: SortOrder
  role: RoleOrderByWithRelationInput
  roleId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum RolesOnUsersScalarFieldEnum {
  createdAt
  roleId
  updatedAt
  userId
}

input RolesOnUsersScalarWhereInput {
  AND: [RolesOnUsersScalarWhereInput!]
  NOT: [RolesOnUsersScalarWhereInput!]
  OR: [RolesOnUsersScalarWhereInput!]
  createdAt: DateTimeFilter
  roleId: IntFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input RolesOnUsersScalarWhereWithAggregatesInput {
  AND: [RolesOnUsersScalarWhereWithAggregatesInput!]
  NOT: [RolesOnUsersScalarWhereWithAggregatesInput!]
  OR: [RolesOnUsersScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  roleId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type RolesOnUsersSumAggregate {
  roleId: Int
}

input RolesOnUsersSumOrderByAggregateInput {
  roleId: SortOrder
}

input RolesOnUsersUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  role: RoleUpdateOneRequiredWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRolesNestedInput
}

input RolesOnUsersUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RolesOnUsersUpdateManyWithWhereWithoutRoleInput {
  data: RolesOnUsersUpdateManyMutationInput!
  where: RolesOnUsersScalarWhereInput!
}

input RolesOnUsersUpdateManyWithWhereWithoutUserInput {
  data: RolesOnUsersUpdateManyMutationInput!
  where: RolesOnUsersScalarWhereInput!
}

input RolesOnUsersUpdateManyWithoutRoleNestedInput {
  connect: [RolesOnUsersWhereUniqueInput!]
  connectOrCreate: [RolesOnUsersCreateOrConnectWithoutRoleInput!]
  create: [RolesOnUsersCreateWithoutRoleInput!]
  delete: [RolesOnUsersWhereUniqueInput!]
  deleteMany: [RolesOnUsersScalarWhereInput!]
  disconnect: [RolesOnUsersWhereUniqueInput!]
  set: [RolesOnUsersWhereUniqueInput!]
  update: [RolesOnUsersUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [RolesOnUsersUpdateManyWithWhereWithoutRoleInput!]
  upsert: [RolesOnUsersUpsertWithWhereUniqueWithoutRoleInput!]
}

input RolesOnUsersUpdateManyWithoutUserNestedInput {
  connect: [RolesOnUsersWhereUniqueInput!]
  connectOrCreate: [RolesOnUsersCreateOrConnectWithoutUserInput!]
  create: [RolesOnUsersCreateWithoutUserInput!]
  delete: [RolesOnUsersWhereUniqueInput!]
  deleteMany: [RolesOnUsersScalarWhereInput!]
  disconnect: [RolesOnUsersWhereUniqueInput!]
  set: [RolesOnUsersWhereUniqueInput!]
  update: [RolesOnUsersUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [RolesOnUsersUpdateManyWithWhereWithoutUserInput!]
  upsert: [RolesOnUsersUpsertWithWhereUniqueWithoutUserInput!]
}

input RolesOnUsersUpdateWithWhereUniqueWithoutRoleInput {
  data: RolesOnUsersUpdateWithoutRoleInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersUpdateWithWhereUniqueWithoutUserInput {
  data: RolesOnUsersUpdateWithoutUserInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersUpdateWithoutRoleInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRolesNestedInput
}

input RolesOnUsersUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  role: RoleUpdateOneRequiredWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RolesOnUsersUpsertWithWhereUniqueWithoutRoleInput {
  create: RolesOnUsersCreateWithoutRoleInput!
  update: RolesOnUsersUpdateWithoutRoleInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersUpsertWithWhereUniqueWithoutUserInput {
  create: RolesOnUsersCreateWithoutUserInput!
  update: RolesOnUsersUpdateWithoutUserInput!
  where: RolesOnUsersWhereUniqueInput!
}

input RolesOnUsersUserIdRoleIdCompoundUniqueInput {
  roleId: Int!
  userId: String!
}

input RolesOnUsersWhereInput {
  AND: [RolesOnUsersWhereInput!]
  NOT: [RolesOnUsersWhereInput!]
  OR: [RolesOnUsersWhereInput!]
  createdAt: DateTimeFilter
  role: RoleRelationFilter
  roleId: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input RolesOnUsersWhereUniqueInput {
  userId_roleId: RolesOnUsersUserIdRoleIdCompoundUniqueInput
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Ticket {
  _count: TicketCount
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: DateTime!
  description: String!
  developer: User
  developerId: String
  id: String!
  priority: String!
  project: Project!
  projectId: String!
  status: String!
  submitter: User!
  submitterId: String!
  title: String!
  type: String!
  updatedAt: DateTime!
}

type TicketCount {
  comments: Int!
}

type TicketCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  developerId: Int!
  id: Int!
  priority: Int!
  projectId: Int!
  status: Int!
  submitterId: Int!
  title: Int!
  type: Int!
  updatedAt: Int!
}

input TicketCountOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  developerId: SortOrder
  id: SortOrder
  priority: SortOrder
  projectId: SortOrder
  status: SortOrder
  submitterId: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input TicketCreateInput {
  comments: CommentCreateNestedManyWithoutTicketInput
  createdAt: DateTime
  description: String!
  developer: UserCreateNestedOneWithoutTicketsInput
  id: String
  priority: String!
  project: ProjectCreateNestedOneWithoutTicketsInput!
  status: String!
  submitter: UserCreateNestedOneWithoutSubmitInput!
  title: String!
  type: String!
  updatedAt: DateTime
}

input TicketCreateNestedManyWithoutDeveloperInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutDeveloperInput!]
  create: [TicketCreateWithoutDeveloperInput!]
}

input TicketCreateNestedManyWithoutProjectInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutProjectInput!]
  create: [TicketCreateWithoutProjectInput!]
}

input TicketCreateNestedManyWithoutSubmitterInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutSubmitterInput!]
  create: [TicketCreateWithoutSubmitterInput!]
}

input TicketCreateNestedOneWithoutCommentsInput {
  connect: TicketWhereUniqueInput
  connectOrCreate: TicketCreateOrConnectWithoutCommentsInput
  create: TicketCreateWithoutCommentsInput
}

input TicketCreateOrConnectWithoutCommentsInput {
  create: TicketCreateWithoutCommentsInput!
  where: TicketWhereUniqueInput!
}

input TicketCreateOrConnectWithoutDeveloperInput {
  create: TicketCreateWithoutDeveloperInput!
  where: TicketWhereUniqueInput!
}

input TicketCreateOrConnectWithoutProjectInput {
  create: TicketCreateWithoutProjectInput!
  where: TicketWhereUniqueInput!
}

input TicketCreateOrConnectWithoutSubmitterInput {
  create: TicketCreateWithoutSubmitterInput!
  where: TicketWhereUniqueInput!
}

input TicketCreateWithoutCommentsInput {
  createdAt: DateTime
  description: String!
  developer: UserCreateNestedOneWithoutTicketsInput
  id: String
  priority: String!
  project: ProjectCreateNestedOneWithoutTicketsInput!
  status: String!
  submitter: UserCreateNestedOneWithoutSubmitInput!
  title: String!
  type: String!
  updatedAt: DateTime
}

input TicketCreateWithoutDeveloperInput {
  comments: CommentCreateNestedManyWithoutTicketInput
  createdAt: DateTime
  description: String!
  id: String
  priority: String!
  project: ProjectCreateNestedOneWithoutTicketsInput!
  status: String!
  submitter: UserCreateNestedOneWithoutSubmitInput!
  title: String!
  type: String!
  updatedAt: DateTime
}

input TicketCreateWithoutProjectInput {
  comments: CommentCreateNestedManyWithoutTicketInput
  createdAt: DateTime
  description: String!
  developer: UserCreateNestedOneWithoutTicketsInput
  id: String
  priority: String!
  status: String!
  submitter: UserCreateNestedOneWithoutSubmitInput!
  title: String!
  type: String!
  updatedAt: DateTime
}

input TicketCreateWithoutSubmitterInput {
  comments: CommentCreateNestedManyWithoutTicketInput
  createdAt: DateTime
  description: String!
  developer: UserCreateNestedOneWithoutTicketsInput
  id: String
  priority: String!
  project: ProjectCreateNestedOneWithoutTicketsInput!
  status: String!
  title: String!
  type: String!
  updatedAt: DateTime
}

type TicketGroupBy {
  _count: TicketCountAggregate
  _max: TicketMaxAggregate
  _min: TicketMinAggregate
  createdAt: DateTime!
  description: String!
  developerId: String
  id: String!
  priority: String!
  projectId: String!
  status: String!
  submitterId: String!
  title: String!
  type: String!
  updatedAt: DateTime!
}

input TicketListRelationFilter {
  every: TicketWhereInput
  none: TicketWhereInput
  some: TicketWhereInput
}

type TicketMaxAggregate {
  createdAt: DateTime
  description: String
  developerId: String
  id: String
  priority: String
  projectId: String
  status: String
  submitterId: String
  title: String
  type: String
  updatedAt: DateTime
}

input TicketMaxOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  developerId: SortOrder
  id: SortOrder
  priority: SortOrder
  projectId: SortOrder
  status: SortOrder
  submitterId: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

type TicketMinAggregate {
  createdAt: DateTime
  description: String
  developerId: String
  id: String
  priority: String
  projectId: String
  status: String
  submitterId: String
  title: String
  type: String
  updatedAt: DateTime
}

input TicketMinOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  developerId: SortOrder
  id: SortOrder
  priority: SortOrder
  projectId: SortOrder
  status: SortOrder
  submitterId: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input TicketOrderByRelationAggregateInput {
  _count: SortOrder
}

input TicketOrderByWithAggregationInput {
  _count: TicketCountOrderByAggregateInput
  _max: TicketMaxOrderByAggregateInput
  _min: TicketMinOrderByAggregateInput
  createdAt: SortOrder
  description: SortOrder
  developerId: SortOrder
  id: SortOrder
  priority: SortOrder
  projectId: SortOrder
  status: SortOrder
  submitterId: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input TicketOrderByWithRelationInput {
  comments: CommentOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  developer: UserOrderByWithRelationInput
  developerId: SortOrder
  id: SortOrder
  priority: SortOrder
  project: ProjectOrderByWithRelationInput
  projectId: SortOrder
  status: SortOrder
  submitter: UserOrderByWithRelationInput
  submitterId: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input TicketRelationFilter {
  is: TicketWhereInput
  isNot: TicketWhereInput
}

enum TicketScalarFieldEnum {
  createdAt
  description
  developerId
  id
  priority
  projectId
  status
  submitterId
  title
  type
  updatedAt
}

input TicketScalarWhereInput {
  AND: [TicketScalarWhereInput!]
  NOT: [TicketScalarWhereInput!]
  OR: [TicketScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  developerId: StringNullableFilter
  id: StringFilter
  priority: StringFilter
  projectId: StringFilter
  status: StringFilter
  submitterId: StringFilter
  title: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input TicketScalarWhereWithAggregatesInput {
  AND: [TicketScalarWhereWithAggregatesInput!]
  NOT: [TicketScalarWhereWithAggregatesInput!]
  OR: [TicketScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  developerId: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  priority: StringWithAggregatesFilter
  projectId: StringWithAggregatesFilter
  status: StringWithAggregatesFilter
  submitterId: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  type: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input TicketUpdateInput {
  comments: CommentUpdateManyWithoutTicketNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  developer: UserUpdateOneWithoutTicketsNestedInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTicketsNestedInput
  status: StringFieldUpdateOperationsInput
  submitter: UserUpdateOneRequiredWithoutSubmitNestedInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpdateManyWithWhereWithoutDeveloperInput {
  data: TicketUpdateManyMutationInput!
  where: TicketScalarWhereInput!
}

input TicketUpdateManyWithWhereWithoutProjectInput {
  data: TicketUpdateManyMutationInput!
  where: TicketScalarWhereInput!
}

input TicketUpdateManyWithWhereWithoutSubmitterInput {
  data: TicketUpdateManyMutationInput!
  where: TicketScalarWhereInput!
}

input TicketUpdateManyWithoutDeveloperNestedInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutDeveloperInput!]
  create: [TicketCreateWithoutDeveloperInput!]
  delete: [TicketWhereUniqueInput!]
  deleteMany: [TicketScalarWhereInput!]
  disconnect: [TicketWhereUniqueInput!]
  set: [TicketWhereUniqueInput!]
  update: [TicketUpdateWithWhereUniqueWithoutDeveloperInput!]
  updateMany: [TicketUpdateManyWithWhereWithoutDeveloperInput!]
  upsert: [TicketUpsertWithWhereUniqueWithoutDeveloperInput!]
}

input TicketUpdateManyWithoutProjectNestedInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutProjectInput!]
  create: [TicketCreateWithoutProjectInput!]
  delete: [TicketWhereUniqueInput!]
  deleteMany: [TicketScalarWhereInput!]
  disconnect: [TicketWhereUniqueInput!]
  set: [TicketWhereUniqueInput!]
  update: [TicketUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [TicketUpdateManyWithWhereWithoutProjectInput!]
  upsert: [TicketUpsertWithWhereUniqueWithoutProjectInput!]
}

input TicketUpdateManyWithoutSubmitterNestedInput {
  connect: [TicketWhereUniqueInput!]
  connectOrCreate: [TicketCreateOrConnectWithoutSubmitterInput!]
  create: [TicketCreateWithoutSubmitterInput!]
  delete: [TicketWhereUniqueInput!]
  deleteMany: [TicketScalarWhereInput!]
  disconnect: [TicketWhereUniqueInput!]
  set: [TicketWhereUniqueInput!]
  update: [TicketUpdateWithWhereUniqueWithoutSubmitterInput!]
  updateMany: [TicketUpdateManyWithWhereWithoutSubmitterInput!]
  upsert: [TicketUpsertWithWhereUniqueWithoutSubmitterInput!]
}

input TicketUpdateOneRequiredWithoutCommentsNestedInput {
  connect: TicketWhereUniqueInput
  connectOrCreate: TicketCreateOrConnectWithoutCommentsInput
  create: TicketCreateWithoutCommentsInput
  update: TicketUpdateWithoutCommentsInput
  upsert: TicketUpsertWithoutCommentsInput
}

input TicketUpdateWithWhereUniqueWithoutDeveloperInput {
  data: TicketUpdateWithoutDeveloperInput!
  where: TicketWhereUniqueInput!
}

input TicketUpdateWithWhereUniqueWithoutProjectInput {
  data: TicketUpdateWithoutProjectInput!
  where: TicketWhereUniqueInput!
}

input TicketUpdateWithWhereUniqueWithoutSubmitterInput {
  data: TicketUpdateWithoutSubmitterInput!
  where: TicketWhereUniqueInput!
}

input TicketUpdateWithoutCommentsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  developer: UserUpdateOneWithoutTicketsNestedInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTicketsNestedInput
  status: StringFieldUpdateOperationsInput
  submitter: UserUpdateOneRequiredWithoutSubmitNestedInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpdateWithoutDeveloperInput {
  comments: CommentUpdateManyWithoutTicketNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTicketsNestedInput
  status: StringFieldUpdateOperationsInput
  submitter: UserUpdateOneRequiredWithoutSubmitNestedInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpdateWithoutProjectInput {
  comments: CommentUpdateManyWithoutTicketNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  developer: UserUpdateOneWithoutTicketsNestedInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  status: StringFieldUpdateOperationsInput
  submitter: UserUpdateOneRequiredWithoutSubmitNestedInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpdateWithoutSubmitterInput {
  comments: CommentUpdateManyWithoutTicketNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  developer: UserUpdateOneWithoutTicketsNestedInput
  id: StringFieldUpdateOperationsInput
  priority: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTicketsNestedInput
  status: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TicketUpsertWithWhereUniqueWithoutDeveloperInput {
  create: TicketCreateWithoutDeveloperInput!
  update: TicketUpdateWithoutDeveloperInput!
  where: TicketWhereUniqueInput!
}

input TicketUpsertWithWhereUniqueWithoutProjectInput {
  create: TicketCreateWithoutProjectInput!
  update: TicketUpdateWithoutProjectInput!
  where: TicketWhereUniqueInput!
}

input TicketUpsertWithWhereUniqueWithoutSubmitterInput {
  create: TicketCreateWithoutSubmitterInput!
  update: TicketUpdateWithoutSubmitterInput!
  where: TicketWhereUniqueInput!
}

input TicketUpsertWithoutCommentsInput {
  create: TicketCreateWithoutCommentsInput!
  update: TicketUpdateWithoutCommentsInput!
}

input TicketWhereInput {
  AND: [TicketWhereInput!]
  NOT: [TicketWhereInput!]
  OR: [TicketWhereInput!]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  description: StringFilter
  developer: UserRelationFilter
  developerId: StringNullableFilter
  id: StringFilter
  priority: StringFilter
  project: ProjectRelationFilter
  projectId: StringFilter
  status: StringFilter
  submitter: UserRelationFilter
  submitterId: StringFilter
  title: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input TicketWhereUniqueInput {
  id: String
}

type User {
  _count: UserCount
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  email: String!
  firstName: String!
  id: String!
  imageUrl: String
  lastName: String!
  projects(cursor: ProjectsOnUserWhereUniqueInput, distinct: [ProjectsOnUserScalarFieldEnum!], orderBy: [ProjectsOnUserOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectsOnUserWhereInput): [ProjectsOnUser!]!
  roles(cursor: RolesOnUsersWhereUniqueInput, distinct: [RolesOnUsersScalarFieldEnum!], orderBy: [RolesOnUsersOrderByWithRelationInput!], skip: Int, take: Int, where: RolesOnUsersWhereInput): [RolesOnUsers!]!
  submit(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
  tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByWithRelationInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
  username: String!
}

type UserCount {
  comments: Int!
  projects: Int!
  roles: Int!
  submit: Int!
  tickets: Int!
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  id: Int!
  imageUrl: Int!
  lastName: Int!
  password: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  lastName: SortOrder
  username: SortOrder
}

input UserCreateInput {
  comments: CommentCreateNestedManyWithoutCommenterInput
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  projects: ProjectsOnUserCreateNestedManyWithoutUserInput
  roles: RolesOnUsersCreateNestedManyWithoutUserInput
  submit: TicketCreateNestedManyWithoutSubmitterInput
  tickets: TicketCreateNestedManyWithoutDeveloperInput
  username: String!
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
}

input UserCreateNestedOneWithoutRolesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRolesInput
  create: UserCreateWithoutRolesInput
}

input UserCreateNestedOneWithoutSubmitInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubmitInput
  create: UserCreateWithoutSubmitInput
}

input UserCreateNestedOneWithoutTicketsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTicketsInput
  create: UserCreateWithoutTicketsInput
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSubmitInput {
  create: UserCreateWithoutSubmitInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTicketsInput {
  create: UserCreateWithoutTicketsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCommentsInput {
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  projects: ProjectsOnUserCreateNestedManyWithoutUserInput
  roles: RolesOnUsersCreateNestedManyWithoutUserInput
  submit: TicketCreateNestedManyWithoutSubmitterInput
  tickets: TicketCreateNestedManyWithoutDeveloperInput
  username: String!
}

input UserCreateWithoutProjectsInput {
  comments: CommentCreateNestedManyWithoutCommenterInput
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  roles: RolesOnUsersCreateNestedManyWithoutUserInput
  submit: TicketCreateNestedManyWithoutSubmitterInput
  tickets: TicketCreateNestedManyWithoutDeveloperInput
  username: String!
}

input UserCreateWithoutRolesInput {
  comments: CommentCreateNestedManyWithoutCommenterInput
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  projects: ProjectsOnUserCreateNestedManyWithoutUserInput
  submit: TicketCreateNestedManyWithoutSubmitterInput
  tickets: TicketCreateNestedManyWithoutDeveloperInput
  username: String!
}

input UserCreateWithoutSubmitInput {
  comments: CommentCreateNestedManyWithoutCommenterInput
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  projects: ProjectsOnUserCreateNestedManyWithoutUserInput
  roles: RolesOnUsersCreateNestedManyWithoutUserInput
  tickets: TicketCreateNestedManyWithoutDeveloperInput
  username: String!
}

input UserCreateWithoutTicketsInput {
  comments: CommentCreateNestedManyWithoutCommenterInput
  email: String!
  firstName: String!
  id: String
  imageUrl: String
  lastName: String!
  password: String!
  projects: ProjectsOnUserCreateNestedManyWithoutUserInput
  roles: RolesOnUsersCreateNestedManyWithoutUserInput
  submit: TicketCreateNestedManyWithoutSubmitterInput
  username: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  email: String!
  firstName: String!
  id: String!
  imageUrl: String
  lastName: String!
  password: String!
  username: String!
}

type UserMaxAggregate {
  email: String
  firstName: String
  id: String
  imageUrl: String
  lastName: String
  password: String
  username: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  lastName: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  email: String
  firstName: String
  id: String
  imageUrl: String
  lastName: String
  password: String
  username: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  lastName: SortOrder
  username: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  lastName: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationInput {
  comments: CommentOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  imageUrl: SortOrder
  lastName: SortOrder
  projects: ProjectsOnUserOrderByRelationAggregateInput
  roles: RolesOnUsersOrderByRelationAggregateInput
  submit: TicketOrderByRelationAggregateInput
  tickets: TicketOrderByRelationAggregateInput
  username: SortOrder
}

type UserPaginatedResponse {
  currentPage: Int!
  hasNextPage: Boolean!
  hasPrevPage: Boolean!
  itemCount: Int!
  items: [User!]!
  totalCount: Int!
  totalPages: Int!
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  email
  firstName
  id
  imageUrl
  lastName
  password
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  imageUrl: StringNullableWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  username: StringWithAggregatesFilter
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutCommenterNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  projects: ProjectsOnUserUpdateManyWithoutUserNestedInput
  roles: RolesOnUsersUpdateManyWithoutUserNestedInput
  submit: TicketUpdateManyWithoutSubmitterNestedInput
  tickets: TicketUpdateManyWithoutDeveloperNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCommentsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutProjectsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
  update: UserUpdateWithoutProjectsInput
  upsert: UserUpsertWithoutProjectsInput
}

input UserUpdateOneRequiredWithoutRolesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRolesInput
  create: UserCreateWithoutRolesInput
  update: UserUpdateWithoutRolesInput
  upsert: UserUpsertWithoutRolesInput
}

input UserUpdateOneRequiredWithoutSubmitNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubmitInput
  create: UserCreateWithoutSubmitInput
  update: UserUpdateWithoutSubmitInput
  upsert: UserUpsertWithoutSubmitInput
}

input UserUpdateOneWithoutTicketsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTicketsInput
  create: UserCreateWithoutTicketsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTicketsInput
  upsert: UserUpsertWithoutTicketsInput
}

input UserUpdateWithoutCommentsInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  projects: ProjectsOnUserUpdateManyWithoutUserNestedInput
  roles: RolesOnUsersUpdateManyWithoutUserNestedInput
  submit: TicketUpdateManyWithoutSubmitterNestedInput
  tickets: TicketUpdateManyWithoutDeveloperNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutProjectsInput {
  comments: CommentUpdateManyWithoutCommenterNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  roles: RolesOnUsersUpdateManyWithoutUserNestedInput
  submit: TicketUpdateManyWithoutSubmitterNestedInput
  tickets: TicketUpdateManyWithoutDeveloperNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutRolesInput {
  comments: CommentUpdateManyWithoutCommenterNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  projects: ProjectsOnUserUpdateManyWithoutUserNestedInput
  submit: TicketUpdateManyWithoutSubmitterNestedInput
  tickets: TicketUpdateManyWithoutDeveloperNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutSubmitInput {
  comments: CommentUpdateManyWithoutCommenterNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  projects: ProjectsOnUserUpdateManyWithoutUserNestedInput
  roles: RolesOnUsersUpdateManyWithoutUserNestedInput
  tickets: TicketUpdateManyWithoutDeveloperNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTicketsInput {
  comments: CommentUpdateManyWithoutCommenterNestedInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  imageUrl: NullableStringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  projects: ProjectsOnUserUpdateManyWithoutUserNestedInput
  roles: RolesOnUsersUpdateManyWithoutUserNestedInput
  submit: TicketUpdateManyWithoutSubmitterNestedInput
  username: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
}

input UserUpsertWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsInput!
}

input UserUpsertWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  update: UserUpdateWithoutRolesInput!
}

input UserUpsertWithoutSubmitInput {
  create: UserCreateWithoutSubmitInput!
  update: UserUpdateWithoutSubmitInput!
}

input UserUpsertWithoutTicketsInput {
  create: UserCreateWithoutTicketsInput!
  update: UserUpdateWithoutTicketsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  comments: CommentListRelationFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  imageUrl: StringNullableFilter
  lastName: StringFilter
  projects: ProjectsOnUserListRelationFilter
  roles: RolesOnUsersListRelationFilter
  submit: TicketListRelationFilter
  tickets: TicketListRelationFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  username: String
}